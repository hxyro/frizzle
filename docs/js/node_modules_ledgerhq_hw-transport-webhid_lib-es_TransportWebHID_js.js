/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_ledgerhq_hw-transport-webhid_lib-es_TransportWebHID_js"],{

/***/ "./node_modules/@ledgerhq/devices/lib-es/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/lib-es/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DeviceModelId\": function() { return /* binding */ DeviceModelId; },\n/* harmony export */   \"IICCID\": function() { return /* binding */ IICCID; },\n/* harmony export */   \"IIGenericHID\": function() { return /* binding */ IIGenericHID; },\n/* harmony export */   \"IIKeyboardHID\": function() { return /* binding */ IIKeyboardHID; },\n/* harmony export */   \"IIU2F\": function() { return /* binding */ IIU2F; },\n/* harmony export */   \"IIWebUSB\": function() { return /* binding */ IIWebUSB; },\n/* harmony export */   \"getBluetoothServiceUuids\": function() { return /* binding */ getBluetoothServiceUuids; },\n/* harmony export */   \"getDeviceModel\": function() { return /* binding */ getDeviceModel; },\n/* harmony export */   \"getInfosForServiceUuid\": function() { return /* binding */ getInfosForServiceUuid; },\n/* harmony export */   \"identifyProductName\": function() { return /* binding */ identifyProductName; },\n/* harmony export */   \"identifyTargetId\": function() { return /* binding */ identifyTargetId; },\n/* harmony export */   \"identifyUSBProductId\": function() { return /* binding */ identifyUSBProductId; },\n/* harmony export */   \"ledgerUSBVendorId\": function() { return /* binding */ ledgerUSBVendorId; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/index.js\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar __assign = undefined && undefined.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar _a;\n\n\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\n\nvar IIGenericHID = 0x01;\nvar IIKeyboardHID = 0x02;\nvar IIU2F = 0x04;\nvar IICCID = 0x08;\nvar IIWebUSB = 0x10;\nvar DeviceModelId;\n\n(function (DeviceModelId) {\n  DeviceModelId[\"blue\"] = \"blue\";\n  DeviceModelId[\"nanoS\"] = \"nanoS\";\n  DeviceModelId[\"nanoSP\"] = \"nanoSP\";\n  DeviceModelId[\"nanoX\"] = \"nanoX\";\n})(DeviceModelId || (DeviceModelId = {}));\n\nvar devices = (_a = {}, _a[DeviceModelId.blue] = {\n  id: DeviceModelId.blue,\n  productName: \"Ledger Blue\",\n  productIdMM: 0x00,\n  legacyUsbProductId: 0x0000,\n  usbOnly: true,\n  memorySize: 480 * 1024,\n  masks: [0x31000000, 0x31010000],\n  getBlockSize: function (_firwareVersion) {\n    return 4 * 1024;\n  }\n}, _a[DeviceModelId.nanoS] = {\n  id: DeviceModelId.nanoS,\n  productName: \"Ledger Nano S\",\n  productIdMM: 0x10,\n  legacyUsbProductId: 0x0001,\n  usbOnly: true,\n  memorySize: 320 * 1024,\n  masks: [0x31100000],\n  getBlockSize: function (firmwareVersion) {\n    var _a;\n\n    return semver__WEBPACK_IMPORTED_MODULE_1___default().lt((_a = semver__WEBPACK_IMPORTED_MODULE_1___default().coerce(firmwareVersion)) !== null && _a !== void 0 ? _a : \"\", \"2.0.0\") ? 4 * 1024 : 2 * 1024;\n  }\n}, _a[DeviceModelId.nanoSP] = {\n  id: DeviceModelId.nanoSP,\n  productName: \"Ledger Nano S Plus\",\n  productIdMM: 0x50,\n  legacyUsbProductId: 0x0005,\n  usbOnly: true,\n  memorySize: 1533 * 1024,\n  masks: [0x33100000],\n  getBlockSize: function (_firmwareVersion) {\n    return 32;\n  }\n}, _a[DeviceModelId.nanoX] = {\n  id: DeviceModelId.nanoX,\n  productName: \"Ledger Nano X\",\n  productIdMM: 0x40,\n  legacyUsbProductId: 0x0004,\n  usbOnly: false,\n  memorySize: 2 * 1024 * 1024,\n  masks: [0x33000000],\n  getBlockSize: function (_firwareVersion) {\n    return 4 * 1024;\n  },\n  bluetoothSpec: [{\n    // this is the legacy one (prototype version). we will eventually drop it.\n    serviceUuid: \"d973f2e0-b19e-11e2-9e96-0800200c9a66\",\n    notifyUuid: \"d973f2e1-b19e-11e2-9e96-0800200c9a66\",\n    writeUuid: \"d973f2e2-b19e-11e2-9e96-0800200c9a66\",\n    writeCmdUuid: \"d973f2e3-b19e-11e2-9e96-0800200c9a66\"\n  }, {\n    serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n    notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n    writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n    writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\"\n  }]\n}, _a);\nvar productMap = {\n  Blue: DeviceModelId.blue,\n  \"Nano S\": DeviceModelId.nanoS,\n  \"Nano X\": DeviceModelId.nanoX\n};\nvar devicesList = Object.values(devices);\n/**\n *\n */\n\nvar ledgerUSBVendorId = 0x2c97;\n/**\n *\n */\n\nvar getDeviceModel = function (id) {\n  var info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\n\nvar identifyTargetId = function (targetId) {\n  var deviceModel = devicesList.find(function (_a) {\n    var masks = _a.masks;\n    return masks.find(function (mask) {\n      return (targetId & 0xffff0000) === mask;\n    });\n  });\n  return deviceModel;\n};\n/**\n *\n */\n\nvar identifyUSBProductId = function (usbProductId) {\n  var legacy = devicesList.find(function (d) {\n    return d.legacyUsbProductId === usbProductId;\n  });\n  if (legacy) return legacy;\n  var mm = usbProductId >> 8;\n  var deviceModel = devicesList.find(function (d) {\n    return d.productIdMM === mm;\n  });\n  return deviceModel;\n};\nvar identifyProductName = function (productName) {\n  var productId = productMap[productName];\n\n  if (!productId && productName.startsWith(\"Nano S\")) {\n    productId = DeviceModelId.nanoSP;\n  }\n\n  var deviceModel = devicesList.find(function (d) {\n    return d.id === productId;\n  });\n  return deviceModel;\n};\nvar bluetoothServices = [];\nvar serviceUuidToInfos = {};\n\nfor (var id in devices) {\n  var deviceModel = devices[id];\n  var bluetoothSpec = deviceModel.bluetoothSpec;\n\n  if (bluetoothSpec) {\n    for (var i = 0; i < bluetoothSpec.length; i++) {\n      var spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, \"\")] = __assign({\n        deviceModel: deviceModel\n      }, spec);\n    }\n  }\n}\n/**\n *\n */\n\n\nvar getBluetoothServiceUuids = function () {\n  return bluetoothServices;\n};\n/**\n *\n */\n\nvar getInfosForServiceUuid = function (uuid) {\n  return serviceUuidToInfos[uuid.toLowerCase()];\n};\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/lib-es/index.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/lib/hid-framing.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/lib/hid-framing.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nexports.__esModule = true;\n\nvar errors_1 = __webpack_require__(/*! @ledgerhq/errors */ \"./node_modules/@ledgerhq/errors/lib-es/index.js\");\n\nvar Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  var b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nvar initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0\n};\n/**\n *\n */\n\nvar createHIDframing = function (channel, packetSize) {\n  return {\n    makeBlocks: function (apdu) {\n      var data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      var blockSize = packetSize - 5;\n      var nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n      var blocks = [];\n\n      for (var i = 0; i < nbBlocks; i++) {\n        var head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        var chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n    reduceResponse: function (acc, chunk) {\n      var _a = acc || initialAcc,\n          data = _a.data,\n          dataLength = _a.dataLength,\n          sequence = _a.sequence;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new errors_1.TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new errors_1.TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new errors_1.TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      var chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data: data,\n        dataLength: dataLength,\n        sequence: sequence\n      };\n    },\n    getReducedResult: function (acc) {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    }\n  };\n};\n\nexports[\"default\"] = createHIDframing;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/lib/hid-framing.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/lru-cache/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/lru-cache/index.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.typed-array.at.js */ \"./node_modules/core-js/modules/es.typed-array.at.js\");\n\n__webpack_require__(/*! core-js/modules/es.typed-array.set.js */ \"./node_modules/core-js/modules/es.typed-array.set.js\");\n\n__webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n\nconst perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;\nconst hasAbortController = typeof AbortController !== 'undefined'; // minimal backwards-compatibility polyfill\n\nconst AC = hasAbortController ? AbortController : Object.assign(class AbortController {\n  constructor() {\n    this.signal = new AC.AbortSignal();\n  }\n\n  abort() {\n    this.signal.aborted = true;\n  }\n\n}, {\n  AbortSignal: class AbortSignal {\n    constructor() {\n      this.aborted = false;\n    }\n\n  }\n});\nconst warned = new Set();\n\nconst deprecatedOption = (opt, instead) => {\n  const code = `LRU_CACHE_OPTION_${opt}`;\n\n  if (shouldWarn(code)) {\n    warn(code, `${opt} option`, `options.${instead}`, LRUCache);\n  }\n};\n\nconst deprecatedMethod = (method, instead) => {\n  const code = `LRU_CACHE_METHOD_${method}`;\n\n  if (shouldWarn(code)) {\n    const {\n      prototype\n    } = LRUCache;\n    const {\n      get\n    } = Object.getOwnPropertyDescriptor(prototype, method);\n    warn(code, `${method} method`, `cache.${instead}()`, get);\n  }\n};\n\nconst deprecatedProperty = (field, instead) => {\n  const code = `LRU_CACHE_PROPERTY_${field}`;\n\n  if (shouldWarn(code)) {\n    const {\n      prototype\n    } = LRUCache;\n    const {\n      get\n    } = Object.getOwnPropertyDescriptor(prototype, field);\n    warn(code, `${field} property`, `cache.${instead}`, get);\n  }\n};\n\nconst emitWarning = (...a) => {\n  typeof process === 'object' && process && typeof process.emitWarning === 'function' ? process.emitWarning(...a) : console.error(...a);\n};\n\nconst shouldWarn = code => !warned.has(code);\n\nconst warn = (code, what, instead, fn) => {\n  warned.add(code);\n  const msg = `The ${what} is deprecated. Please use ${instead} instead.`;\n  emitWarning(msg, 'DeprecationWarning', code, fn);\n};\n\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */\n\n\nconst getUintArray = max => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size);\n    this.fill(0);\n  }\n\n}\n\nclass Stack {\n  constructor(max) {\n    if (max === 0) {\n      return [];\n    }\n\n    const UintArray = getUintArray(max);\n    this.heap = new UintArray(max);\n    this.length = 0;\n  }\n\n  push(n) {\n    this.heap[this.length++] = n;\n  }\n\n  pop() {\n    return this.heap[--this.length];\n  }\n\n}\n\nclass LRUCache {\n  constructor(options = {}) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      sizeCalculation,\n      fetchMethod\n    } = options; // deprecated options, don't trigger a warning for getting them if\n    // the thing being passed in is another LRUCache we're copying.\n\n    const {\n      length,\n      maxAge,\n      stale\n    } = options instanceof LRUCache ? {} : options;\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer');\n    }\n\n    const UintArray = max ? getUintArray(max) : Array;\n\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max);\n    }\n\n    this.max = max;\n    this.maxSize = maxSize;\n    this.sizeCalculation = sizeCalculation || length;\n\n    if (this.sizeCalculation) {\n      if (!this.maxSize) {\n        throw new TypeError('cannot set sizeCalculation without setting maxSize');\n      }\n\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function');\n      }\n    }\n\n    this.fetchMethod = fetchMethod || null;\n\n    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified');\n    }\n\n    this.keyMap = new Map();\n    this.keyList = new Array(max).fill(null);\n    this.valList = new Array(max).fill(null);\n    this.next = new UintArray(max);\n    this.prev = new UintArray(max);\n    this.head = 0;\n    this.tail = 0;\n    this.free = new Stack(max);\n    this.initialFill = 1;\n    this.size = 0;\n\n    if (typeof dispose === 'function') {\n      this.dispose = dispose;\n    }\n\n    if (typeof disposeAfter === 'function') {\n      this.disposeAfter = disposeAfter;\n      this.disposed = [];\n    } else {\n      this.disposeAfter = null;\n      this.disposed = null;\n    }\n\n    this.noDisposeOnSet = !!noDisposeOnSet;\n    this.noUpdateTTL = !!noUpdateTTL;\n\n    if (this.maxSize !== 0) {\n      if (!isPosInt(this.maxSize)) {\n        throw new TypeError('maxSize must be a positive integer if specified');\n      }\n\n      this.initializeSizeTracking();\n    }\n\n    this.allowStale = !!allowStale || !!stale;\n    this.updateAgeOnGet = !!updateAgeOnGet;\n    this.updateAgeOnHas = !!updateAgeOnHas;\n    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n    this.ttlAutopurge = !!ttlAutopurge;\n    this.ttl = ttl || maxAge || 0;\n\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified');\n      }\n\n      this.initializeTTLTracking();\n    } // do not allow completely unbounded caches\n\n\n    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n      throw new TypeError('At least one of max, maxSize, or ttl is required');\n    }\n\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED';\n\n      if (shouldWarn(code)) {\n        warned.add(code);\n        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n      }\n    }\n\n    if (stale) {\n      deprecatedOption('stale', 'allowStale');\n    }\n\n    if (maxAge) {\n      deprecatedOption('maxAge', 'ttl');\n    }\n\n    if (length) {\n      deprecatedOption('length', 'sizeCalculation');\n    }\n  }\n\n  getRemainingTTL(key) {\n    return this.has(key, {\n      updateAgeOnHas: false\n    }) ? Infinity : 0;\n  }\n\n  initializeTTLTracking() {\n    this.ttls = new ZeroArray(this.max);\n    this.starts = new ZeroArray(this.max);\n\n    this.setItemTTL = (index, ttl) => {\n      this.starts[index] = ttl !== 0 ? perf.now() : 0;\n      this.ttls[index] = ttl;\n\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.isStale(index)) {\n            this.delete(this.keyList[index]);\n          }\n        }, ttl + 1);\n        /* istanbul ignore else - unref() not supported on all platforms */\n\n        if (t.unref) {\n          t.unref();\n        }\n      }\n    };\n\n    this.updateItemAge = index => {\n      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;\n    }; // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n\n\n    let cachedNow = 0;\n\n    const getNow = () => {\n      const n = perf.now();\n\n      if (this.ttlResolution > 0) {\n        cachedNow = n;\n        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);\n        /* istanbul ignore else - not available on all platforms */\n\n        if (t.unref) {\n          t.unref();\n        }\n      }\n\n      return n;\n    };\n\n    this.getRemainingTTL = key => {\n      const index = this.keyMap.get(key);\n\n      if (index === undefined) {\n        return 0;\n      }\n\n      return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());\n    };\n\n    this.isStale = index => {\n      return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];\n    };\n  }\n\n  updateItemAge(index) {}\n\n  setItemTTL(index, ttl) {}\n\n  isStale(index) {\n    return false;\n  }\n\n  initializeSizeTracking() {\n    this.calculatedSize = 0;\n    this.sizes = new ZeroArray(this.max);\n\n    this.removeItemSize = index => this.calculatedSize -= this.sizes[index];\n\n    this.requireSize = (k, v, size, sizeCalculation) => {\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function');\n          }\n\n          size = sizeCalculation(v, k);\n\n          if (!isPosInt(size)) {\n            throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n          }\n        } else {\n          throw new TypeError('invalid size value (must be positive integer)');\n        }\n      }\n\n      return size;\n    };\n\n    this.addItemSize = (index, v, k, size) => {\n      this.sizes[index] = size;\n      const maxSize = this.maxSize - this.sizes[index];\n\n      while (this.calculatedSize > maxSize) {\n        this.evict(true);\n      }\n\n      this.calculatedSize += this.sizes[index];\n    };\n\n    this.delete = k => {\n      if (this.size !== 0) {\n        const index = this.keyMap.get(k);\n\n        if (index !== undefined) {\n          this.calculatedSize -= this.sizes[index];\n        }\n      }\n\n      return LRUCache.prototype.delete.call(this, k);\n    };\n  }\n\n  removeItemSize(index) {}\n\n  addItemSize(index, v, k, size) {}\n\n  requireSize(k, v, size, sizeCalculation) {\n    if (size || sizeCalculation) {\n      throw new TypeError('cannot set size without setting maxSize on cache');\n    }\n  }\n\n  *indexes({\n    allowStale = this.allowStale\n  } = {}) {\n    if (this.size) {\n      for (let i = this.tail; true;) {\n        if (!this.isValidIndex(i)) {\n          break;\n        }\n\n        if (allowStale || !this.isStale(i)) {\n          yield i;\n        }\n\n        if (i === this.head) {\n          break;\n        } else {\n          i = this.prev[i];\n        }\n      }\n    }\n  }\n\n  *rindexes({\n    allowStale = this.allowStale\n  } = {}) {\n    if (this.size) {\n      for (let i = this.head; true;) {\n        if (!this.isValidIndex(i)) {\n          break;\n        }\n\n        if (allowStale || !this.isStale(i)) {\n          yield i;\n        }\n\n        if (i === this.tail) {\n          break;\n        } else {\n          i = this.next[i];\n        }\n      }\n    }\n  }\n\n  isValidIndex(index) {\n    return this.keyMap.get(this.keyList[index]) === index;\n  }\n\n  *entries() {\n    for (const i of this.indexes()) {\n      yield [this.keyList[i], this.valList[i]];\n    }\n  }\n\n  *rentries() {\n    for (const i of this.rindexes()) {\n      yield [this.keyList[i], this.valList[i]];\n    }\n  }\n\n  *keys() {\n    for (const i of this.indexes()) {\n      yield this.keyList[i];\n    }\n  }\n\n  *rkeys() {\n    for (const i of this.rindexes()) {\n      yield this.keyList[i];\n    }\n  }\n\n  *values() {\n    for (const i of this.indexes()) {\n      yield this.valList[i];\n    }\n  }\n\n  *rvalues() {\n    for (const i of this.rindexes()) {\n      yield this.valList[i];\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  find(fn, getOptions = {}) {\n    for (const i of this.indexes()) {\n      if (fn(this.valList[i], this.keyList[i], this)) {\n        return this.get(this.keyList[i], getOptions);\n      }\n    }\n  }\n\n  forEach(fn, thisp = this) {\n    for (const i of this.indexes()) {\n      fn.call(thisp, this.valList[i], this.keyList[i], this);\n    }\n  }\n\n  rforEach(fn, thisp = this) {\n    for (const i of this.rindexes()) {\n      fn.call(thisp, this.valList[i], this.keyList[i], this);\n    }\n  }\n\n  get prune() {\n    deprecatedMethod('prune', 'purgeStale');\n    return this.purgeStale;\n  }\n\n  purgeStale() {\n    let deleted = false;\n\n    for (const i of this.rindexes({\n      allowStale: true\n    })) {\n      if (this.isStale(i)) {\n        this.delete(this.keyList[i]);\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  dump() {\n    const arr = [];\n\n    for (const i of this.indexes()) {\n      const key = this.keyList[i];\n      const value = this.valList[i];\n      const entry = {\n        value\n      };\n\n      if (this.ttls) {\n        entry.ttl = this.ttls[i];\n      }\n\n      if (this.sizes) {\n        entry.size = this.sizes[i];\n      }\n\n      arr.unshift([key, entry]);\n    }\n\n    return arr;\n  }\n\n  load(arr) {\n    this.clear();\n\n    for (const [key, entry] of arr) {\n      this.set(key, entry.value, entry);\n    }\n  }\n\n  dispose(v, k, reason) {}\n\n  set(k, v, {\n    ttl = this.ttl,\n    noDisposeOnSet = this.noDisposeOnSet,\n    size = 0,\n    sizeCalculation = this.sizeCalculation,\n    noUpdateTTL = this.noUpdateTTL\n  } = {}) {\n    size = this.requireSize(k, v, size, sizeCalculation);\n    let index = this.size === 0 ? undefined : this.keyMap.get(k);\n\n    if (index === undefined) {\n      // addition\n      index = this.newIndex();\n      this.keyList[index] = k;\n      this.valList[index] = v;\n      this.keyMap.set(k, index);\n      this.next[this.tail] = index;\n      this.prev[index] = this.tail;\n      this.tail = index;\n      this.size++;\n      this.addItemSize(index, v, k, size);\n      noUpdateTTL = false;\n    } else {\n      // update\n      const oldVal = this.valList[index];\n\n      if (v !== oldVal) {\n        if (this.isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort();\n        } else {\n          if (!noDisposeOnSet) {\n            this.dispose(oldVal, k, 'set');\n\n            if (this.disposeAfter) {\n              this.disposed.push([oldVal, k, 'set']);\n            }\n          }\n        }\n\n        this.removeItemSize(index);\n        this.valList[index] = v;\n        this.addItemSize(index, v, k, size);\n      }\n\n      this.moveToTail(index);\n    }\n\n    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n      this.initializeTTLTracking();\n    }\n\n    if (!noUpdateTTL) {\n      this.setItemTTL(index, ttl);\n    }\n\n    if (this.disposeAfter) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n\n    return this;\n  }\n\n  newIndex() {\n    if (this.size === 0) {\n      return this.tail;\n    }\n\n    if (this.size === this.max && this.max !== 0) {\n      return this.evict(false);\n    }\n\n    if (this.free.length !== 0) {\n      return this.free.pop();\n    } // initial fill, just keep writing down the list\n\n\n    return this.initialFill++;\n  }\n\n  pop() {\n    if (this.size) {\n      const val = this.valList[this.head];\n      this.evict(true);\n      return val;\n    }\n  }\n\n  evict(free) {\n    const head = this.head;\n    const k = this.keyList[head];\n    const v = this.valList[head];\n\n    if (this.isBackgroundFetch(v)) {\n      v.__abortController.abort();\n    } else {\n      this.dispose(v, k, 'evict');\n\n      if (this.disposeAfter) {\n        this.disposed.push([v, k, 'evict']);\n      }\n    }\n\n    this.removeItemSize(head); // if we aren't about to use the index, then null these out\n\n    if (free) {\n      this.keyList[head] = null;\n      this.valList[head] = null;\n      this.free.push(head);\n    }\n\n    this.head = this.next[head];\n    this.keyMap.delete(k);\n    this.size--;\n    return head;\n  }\n\n  has(k, {\n    updateAgeOnHas = this.updateAgeOnHas\n  } = {}) {\n    const index = this.keyMap.get(k);\n\n    if (index !== undefined) {\n      if (!this.isStale(index)) {\n        if (updateAgeOnHas) {\n          this.updateItemAge(index);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  } // like get(), but without any LRU updating or TTL expiration\n\n\n  peek(k, {\n    allowStale = this.allowStale\n  } = {}) {\n    const index = this.keyMap.get(k);\n\n    if (index !== undefined && (allowStale || !this.isStale(index))) {\n      return this.valList[index];\n    }\n  }\n\n  backgroundFetch(k, index, options) {\n    const v = index === undefined ? undefined : this.valList[index];\n\n    if (this.isBackgroundFetch(v)) {\n      return v;\n    }\n\n    const ac = new AC();\n    const fetchOpts = {\n      signal: ac.signal,\n      options\n    };\n    const p = Promise.resolve(this.fetchMethod(k, v, fetchOpts)).then(v => {\n      if (!ac.signal.aborted) {\n        this.set(k, v, fetchOpts.options);\n      }\n\n      return v;\n    });\n    p.__abortController = ac;\n    p.__staleWhileFetching = v;\n\n    if (index === undefined) {\n      this.set(k, p, fetchOpts.options);\n      index = this.keyMap.get(k);\n    } else {\n      this.valList[index] = p;\n    }\n\n    return p;\n  }\n\n  isBackgroundFetch(p) {\n    return p && typeof p === 'object' && typeof p.then === 'function' && Object.prototype.hasOwnProperty.call(p, '__staleWhileFetching');\n  } // this takes the union of get() and set() opts, because it does both\n\n\n  async fetch(k, {\n    allowStale = this.allowStale,\n    updateAgeOnGet = this.updateAgeOnGet,\n    ttl = this.ttl,\n    noDisposeOnSet = this.noDisposeOnSet,\n    size = 0,\n    sizeCalculation = this.sizeCalculation,\n    noUpdateTTL = this.noUpdateTTL\n  } = {}) {\n    if (!this.fetchMethod) {\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet\n      });\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL\n    };\n    let index = this.keyMap.get(k);\n\n    if (index === undefined) {\n      return this.backgroundFetch(k, index, options);\n    } else {\n      // in cache, maybe already fetching\n      const v = this.valList[index];\n\n      if (this.isBackgroundFetch(v)) {\n        return allowStale && v.__staleWhileFetching !== undefined ? v.__staleWhileFetching : v;\n      }\n\n      if (!this.isStale(index)) {\n        this.moveToTail(index);\n\n        if (updateAgeOnGet) {\n          this.updateItemAge(index);\n        }\n\n        return v;\n      } // ok, it is stale, and not already fetching\n      // refresh the cache.\n\n\n      const p = this.backgroundFetch(k, index, options);\n      return allowStale && p.__staleWhileFetching !== undefined ? p.__staleWhileFetching : p;\n    }\n  }\n\n  get(k, {\n    allowStale = this.allowStale,\n    updateAgeOnGet = this.updateAgeOnGet\n  } = {}) {\n    const index = this.keyMap.get(k);\n\n    if (index !== undefined) {\n      const value = this.valList[index];\n      const fetching = this.isBackgroundFetch(value);\n\n      if (this.isStale(index)) {\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          this.delete(k);\n          return allowStale ? value : undefined;\n        } else {\n          return allowStale ? value.__staleWhileFetching : undefined;\n        }\n      } else {\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching,\n        // so we just return undefined\n        if (fetching) {\n          return undefined;\n        }\n\n        this.moveToTail(index);\n\n        if (updateAgeOnGet) {\n          this.updateItemAge(index);\n        }\n\n        return value;\n      }\n    }\n  }\n\n  connect(p, n) {\n    this.prev[n] = p;\n    this.next[p] = n;\n  }\n\n  moveToTail(index) {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.tail) {\n      if (index === this.head) {\n        this.head = this.next[index];\n      } else {\n        this.connect(this.prev[index], this.next[index]);\n      }\n\n      this.connect(this.tail, index);\n      this.tail = index;\n    }\n  }\n\n  get del() {\n    deprecatedMethod('del', 'delete');\n    return this.delete;\n  }\n\n  delete(k) {\n    let deleted = false;\n\n    if (this.size !== 0) {\n      const index = this.keyMap.get(k);\n\n      if (index !== undefined) {\n        deleted = true;\n\n        if (this.size === 1) {\n          this.clear();\n        } else {\n          this.removeItemSize(index);\n          const v = this.valList[index];\n\n          if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort();\n          } else {\n            this.dispose(v, k, 'delete');\n\n            if (this.disposeAfter) {\n              this.disposed.push([v, k, 'delete']);\n            }\n          }\n\n          this.keyMap.delete(k);\n          this.keyList[index] = null;\n          this.valList[index] = null;\n\n          if (index === this.tail) {\n            this.tail = this.prev[index];\n          } else if (index === this.head) {\n            this.head = this.next[index];\n          } else {\n            this.next[this.prev[index]] = this.next[index];\n            this.prev[this.next[index]] = this.prev[index];\n          }\n\n          this.size--;\n          this.free.push(index);\n        }\n      }\n    }\n\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n\n    return deleted;\n  }\n\n  clear() {\n    for (const index of this.rindexes({\n      allowStale: true\n    })) {\n      const v = this.valList[index];\n\n      if (this.isBackgroundFetch(v)) {\n        v.__abortController.abort();\n      } else {\n        const k = this.keyList[index];\n        this.dispose(v, k, 'delete');\n\n        if (this.disposeAfter) {\n          this.disposed.push([v, k, 'delete']);\n        }\n      }\n    }\n\n    this.keyMap.clear();\n    this.valList.fill(null);\n    this.keyList.fill(null);\n\n    if (this.ttls) {\n      this.ttls.fill(0);\n      this.starts.fill(0);\n    }\n\n    if (this.sizes) {\n      this.sizes.fill(0);\n    }\n\n    this.head = 0;\n    this.tail = 0;\n    this.initialFill = 1;\n    this.free.length = 0;\n    this.calculatedSize = 0;\n    this.size = 0;\n\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n  }\n\n  get reset() {\n    deprecatedMethod('reset', 'clear');\n    return this.clear;\n  }\n\n  get length() {\n    deprecatedProperty('length', 'size');\n    return this.size;\n  }\n\n}\n\nmodule.exports = LRUCache;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/lru-cache/index.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/classes/comparator.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/classes/comparator.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n\nconst ANY = Symbol('SemVer ANY'); // hoisted class for cyclic dependency\n\nclass Comparator {\n  static get ANY() {\n    return ANY;\n  }\n\n  constructor(comp, options) {\n    options = parseOptions(options);\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp;\n      } else {\n        comp = comp.value;\n      }\n    }\n\n    debug('comparator', comp, options);\n    this.options = options;\n    this.loose = !!options.loose;\n    this.parse(comp);\n\n    if (this.semver === ANY) {\n      this.value = '';\n    } else {\n      this.value = this.operator + this.semver.version;\n    }\n\n    debug('comp', this);\n  }\n\n  parse(comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n    const m = comp.match(r);\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`);\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : '';\n\n    if (this.operator === '=') {\n      this.operator = '';\n    } // if it literally is just '>' or '' then allow anything.\n\n\n    if (!m[2]) {\n      this.semver = ANY;\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose);\n    }\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  test(version) {\n    debug('Comparator.test', version, this.options.loose);\n\n    if (this.semver === ANY || version === ANY) {\n      return true;\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options);\n      } catch (er) {\n        return false;\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options);\n  }\n\n  intersects(comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required');\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      };\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true;\n      }\n\n      return new Range(comp.value, options).test(this.value);\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true;\n      }\n\n      return new Range(this.value, options).test(comp.semver);\n    }\n\n    const sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');\n    const sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');\n    const sameSemVer = this.semver.version === comp.semver.version;\n    const differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');\n    const oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');\n    const oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');\n    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n  }\n\n}\n\nmodule.exports = Comparator;\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/parse-options.js\");\n\nconst {\n  re,\n  t\n} = __webpack_require__(/*! ../internal/re */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/re.js\");\n\nconst cmp = __webpack_require__(/*! ../functions/cmp */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/cmp.js\");\n\nconst debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/debug.js\");\n\nconst SemVer = __webpack_require__(/*! ./semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst Range = __webpack_require__(/*! ./range */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\");\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/classes/comparator.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n\n// hoisted class for cyclic dependency\nclass Range {\n  constructor(range, options) {\n    options = parseOptions(options);\n\n    if (range instanceof Range) {\n      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {\n        return range;\n      } else {\n        return new Range(range.raw, options);\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value;\n      this.set = [[range]];\n      this.format();\n      return this;\n    }\n\n    this.options = options;\n    this.loose = !!options.loose;\n    this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||\n\n    this.raw = range;\n    this.set = range.split('||') // map the range to a 2d array of comparators\n    .map(r => this.parseRange(r.trim())) // throw out any comparator lists that are empty\n    // this generally means that it was not a valid range, which is allowed\n    // in loose mode, but will still throw if the WHOLE range is invalid.\n    .filter(c => c.length);\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`);\n    } // if we have any that are not the null set, throw out null sets.\n\n\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0];\n      this.set = this.set.filter(c => !isNullSet(c[0]));\n\n      if (this.set.length === 0) {\n        this.set = [first];\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c];\n            break;\n          }\n        }\n      }\n    }\n\n    this.format();\n  }\n\n  format() {\n    this.range = this.set.map(comps => {\n      return comps.join(' ').trim();\n    }).join('||').trim();\n    return this.range;\n  }\n\n  toString() {\n    return this.range;\n  }\n\n  parseRange(range) {\n    range = range.trim(); // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n\n    const memoOpts = Object.keys(this.options).join(',');\n    const memoKey = `parseRange:${memoOpts}:${range}`;\n    const cached = cache.get(memoKey);\n\n    if (cached) {\n      return cached;\n    }\n\n    const loose = this.options.loose; // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));\n    debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);\n    debug('comparator trim', range); // `~ 1.2.3` => `~1.2.3`\n\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`\n\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace); // normalize spaces\n\n    range = range.split(/\\s+/).join(' '); // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range.split(' ').map(comp => parseComparator(comp, this.options)).join(' ').split(/\\s+/) // >=0.0.0 is equivalent to *\n    .map(comp => replaceGTE0(comp, this.options));\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options);\n        return !!comp.match(re[t.COMPARATORLOOSE]);\n      });\n    }\n\n    debug('range list', rangeList); // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n\n    const rangeMap = new Map();\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options));\n\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp];\n      }\n\n      rangeMap.set(comp.value, comp);\n    }\n\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('');\n    }\n\n    const result = [...rangeMap.values()];\n    cache.set(memoKey, result);\n    return result;\n  }\n\n  intersects(range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required');\n    }\n\n    return this.set.some(thisComparators => {\n      return isSatisfiable(thisComparators, options) && range.set.some(rangeComparators => {\n        return isSatisfiable(rangeComparators, options) && thisComparators.every(thisComparator => {\n          return rangeComparators.every(rangeComparator => {\n            return thisComparator.intersects(rangeComparator, options);\n          });\n        });\n      });\n    });\n  } // if ANY of the sets match ALL of its comparators, then pass\n\n\n  test(version) {\n    if (!version) {\n      return false;\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options);\n      } catch (er) {\n        return false;\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nmodule.exports = Range;\n\nconst LRU = __webpack_require__(/*! lru-cache */ \"./node_modules/@ledgerhq/devices/node_modules/lru-cache/index.js\");\n\nconst cache = new LRU({\n  max: 1000\n});\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/parse-options.js\");\n\nconst Comparator = __webpack_require__(/*! ./comparator */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/comparator.js\");\n\nconst debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/debug.js\");\n\nconst SemVer = __webpack_require__(/*! ./semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = __webpack_require__(/*! ../internal/re */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/re.js\");\n\nconst isNullSet = c => c.value === '<0.0.0-0';\n\nconst isAny = c => c.value === ''; // take a set of comparators and determine whether there\n// exists a version which can satisfy it\n\n\nconst isSatisfiable = (comparators, options) => {\n  let result = true;\n  const remainingComparators = comparators.slice();\n  let testComparator = remainingComparators.pop();\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every(otherComparator => {\n      return testComparator.intersects(otherComparator, options);\n    });\n    testComparator = remainingComparators.pop();\n  }\n\n  return result;\n}; // comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\n\n\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options);\n  comp = replaceCarets(comp, options);\n  debug('caret', comp);\n  comp = replaceTildes(comp, options);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, options);\n  debug('xrange', comp);\n  comp = replaceStars(comp, options);\n  debug('stars', comp);\n  return comp;\n};\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'; // ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n\n\nconst replaceTildes = (comp, options) => comp.trim().split(/\\s+/).map(c => {\n  return replaceTilde(c, options);\n}).join(' ');\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr);\n    let ret;\n\n    if (isX(M)) {\n      ret = '';\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;\n    } else if (pr) {\n      debug('replaceTilde pr', pr);\n      ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;\n    }\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}; // ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\n\n\nconst replaceCarets = (comp, options) => comp.trim().split(/\\s+/).map(c => {\n  return replaceCaret(c, options);\n}).join(' ');\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options);\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];\n  const z = options.includePrerelease ? '-0' : '';\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr);\n    let ret;\n\n    if (isX(M)) {\n      ret = '';\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;\n      }\n    } else {\n      debug('no pr');\n\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;\n        } else {\n          ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;\n        }\n      } else {\n        ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;\n      }\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n};\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options);\n  return comp.split(/\\s+/).map(c => {\n    return replaceXRange(c, options);\n  }).join(' ');\n};\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim();\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    const xM = isX(M);\n    const xm = xM || isX(m);\n    const xp = xm || isX(p);\n    const anyX = xp;\n\n    if (gtlt === '=' && anyX) {\n      gtlt = '';\n    } // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n\n\n    pr = options.includePrerelease ? '-0' : '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0;\n      }\n\n      p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>=';\n\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n\n        if (xm) {\n          M = +M + 1;\n        } else {\n          m = +m + 1;\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0';\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`;\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;\n    }\n\n    debug('xRange return', ret);\n    return ret;\n  });\n}; // Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\n\n\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!\n\n  return comp.trim().replace(re[t.STAR], '');\n};\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options);\n  return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');\n}; // This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n\n\nconst hyphenReplace = incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = '';\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;\n  } else if (fpr) {\n    from = `>=${from}`;\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`;\n  }\n\n  if (isX(tM)) {\n    to = '';\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`;\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`;\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`;\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`;\n  } else {\n    to = `<=${to}`;\n  }\n\n  return `${from} ${to}`.trim();\n};\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false;\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n\n      if (set[i].semver === Comparator.ANY) {\n        continue;\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver;\n\n        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {\n          return true;\n        }\n      }\n    } // Version has a -pre, but it's not one of the ones we like.\n\n\n    return false;\n  }\n\n  return true;\n};\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n\nconst debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/debug.js\");\n\nconst {\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER\n} = __webpack_require__(/*! ../internal/constants */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/constants.js\");\n\nconst {\n  re,\n  t\n} = __webpack_require__(/*! ../internal/re */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/re.js\");\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/parse-options.js\");\n\nconst {\n  compareIdentifiers\n} = __webpack_require__(/*! ../internal/identifiers */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/identifiers.js\");\n\nclass SemVer {\n  constructor(version, options) {\n    options = parseOptions(options);\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {\n        return version;\n      } else {\n        version = version.version;\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`);\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);\n    }\n\n    debug('SemVer', version, options);\n    this.options = options;\n    this.loose = !!options.loose; // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n\n    this.includePrerelease = !!options.includePrerelease;\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`);\n    }\n\n    this.raw = version; // these are actually numbers\n\n    this.major = +m[1];\n    this.minor = +m[2];\n    this.patch = +m[3];\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version');\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version');\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version');\n    } // numberify any prerelease numeric ids\n\n\n    if (!m[4]) {\n      this.prerelease = [];\n    } else {\n      this.prerelease = m[4].split('.').map(id => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id;\n\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num;\n          }\n        }\n\n        return id;\n      });\n    }\n\n    this.build = m[5] ? m[5].split('.') : [];\n    this.format();\n  }\n\n  format() {\n    this.version = `${this.major}.${this.minor}.${this.patch}`;\n\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`;\n    }\n\n    return this.version;\n  }\n\n  toString() {\n    return this.version;\n  }\n\n  compare(other) {\n    debug('SemVer.compare', this.version, this.options, other);\n\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0;\n      }\n\n      other = new SemVer(other, this.options);\n    }\n\n    if (other.version === this.version) {\n      return 0;\n    }\n\n    return this.compareMain(other) || this.comparePre(other);\n  }\n\n  compareMain(other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n\n    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);\n  }\n\n  comparePre(other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    } // NOT having a prerelease is > having one\n\n\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1;\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1;\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0;\n    }\n\n    let i = 0;\n\n    do {\n      const a = this.prerelease[i];\n      const b = other.prerelease[i];\n      debug('prerelease compare', i, a, b);\n\n      if (a === undefined && b === undefined) {\n        return 0;\n      } else if (b === undefined) {\n        return 1;\n      } else if (a === undefined) {\n        return -1;\n      } else if (a === b) {\n        continue;\n      } else {\n        return compareIdentifiers(a, b);\n      }\n    } while (++i);\n  }\n\n  compareBuild(other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n\n    let i = 0;\n\n    do {\n      const a = this.build[i];\n      const b = other.build[i];\n      debug('prerelease compare', i, a, b);\n\n      if (a === undefined && b === undefined) {\n        return 0;\n      } else if (b === undefined) {\n        return 1;\n      } else if (a === undefined) {\n        return -1;\n      } else if (a === b) {\n        continue;\n      } else {\n        return compareIdentifiers(a, b);\n      }\n    } while (++i);\n  } // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n\n\n  inc(release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0;\n        this.patch = 0;\n        this.minor = 0;\n        this.major++;\n        this.inc('pre', identifier);\n        break;\n\n      case 'preminor':\n        this.prerelease.length = 0;\n        this.patch = 0;\n        this.minor++;\n        this.inc('pre', identifier);\n        break;\n\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0;\n        this.inc('patch', identifier);\n        this.inc('pre', identifier);\n        break;\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier);\n        }\n\n        this.inc('pre', identifier);\n        break;\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n          this.major++;\n        }\n\n        this.minor = 0;\n        this.patch = 0;\n        this.prerelease = [];\n        break;\n\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++;\n        }\n\n        this.patch = 0;\n        this.prerelease = [];\n        break;\n\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++;\n        }\n\n        this.prerelease = [];\n        break;\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0];\n        } else {\n          let i = this.prerelease.length;\n\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++;\n              i = -2;\n            }\n          }\n\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0);\n          }\n        }\n\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0];\n            }\n          } else {\n            this.prerelease = [identifier, 0];\n          }\n        }\n\n        break;\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`);\n    }\n\n    this.format();\n    this.raw = this.version;\n    return this;\n  }\n\n}\n\nmodule.exports = SemVer;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/clean.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/clean.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/parse.js\");\n\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options);\n  return s ? s.version : null;\n};\n\nmodule.exports = clean;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/clean.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/cmp.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/cmp.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n\nconst eq = __webpack_require__(/*! ./eq */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/eq.js\");\n\nconst neq = __webpack_require__(/*! ./neq */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/neq.js\");\n\nconst gt = __webpack_require__(/*! ./gt */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/gt.js\");\n\nconst gte = __webpack_require__(/*! ./gte */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/gte.js\");\n\nconst lt = __webpack_require__(/*! ./lt */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/lt.js\");\n\nconst lte = __webpack_require__(/*! ./lte */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/lte.js\");\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version;\n      }\n\n      if (typeof b === 'object') {\n        b = b.version;\n      }\n\n      return a === b;\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version;\n      }\n\n      if (typeof b === 'object') {\n        b = b.version;\n      }\n\n      return a !== b;\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose);\n\n    case '!=':\n      return neq(a, b, loose);\n\n    case '>':\n      return gt(a, b, loose);\n\n    case '>=':\n      return gte(a, b, loose);\n\n    case '<':\n      return lt(a, b, loose);\n\n    case '<=':\n      return lte(a, b, loose);\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`);\n  }\n};\n\nmodule.exports = cmp;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/cmp.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/coerce.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/coerce.js ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/parse.js\");\n\nconst {\n  re,\n  t\n} = __webpack_require__(/*! ../internal/re */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/re.js\");\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version;\n  }\n\n  if (typeof version === 'number') {\n    version = String(version);\n  }\n\n  if (typeof version !== 'string') {\n    return null;\n  }\n\n  options = options || {};\n  let match = null;\n\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE]);\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next;\n\n    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n      if (!match || next.index + next[0].length !== match.index + match[0].length) {\n        match = next;\n      }\n\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;\n    } // leave it in a clean state\n\n\n    re[t.COERCERTL].lastIndex = -1;\n  }\n\n  if (match === null) {\n    return null;\n  }\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options);\n};\n\nmodule.exports = coerce;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/coerce.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare-build.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare-build.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose);\n  const versionB = new SemVer(b, loose);\n  return versionA.compare(versionB) || versionA.compareBuild(versionB);\n};\n\nmodule.exports = compareBuild;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare-build.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare-loose.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare-loose.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\");\n\nconst compareLoose = (a, b) => compare(a, b, true);\n\nmodule.exports = compareLoose;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare-loose.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js ***!
  \*********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));\n\nmodule.exports = compare;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/diff.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/diff.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/parse.js\");\n\nconst eq = __webpack_require__(/*! ./eq */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/eq.js\");\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    const v1 = parse(version1);\n    const v2 = parse(version2);\n    const hasPre = v1.prerelease.length || v2.prerelease.length;\n    const prefix = hasPre ? 'pre' : '';\n    const defaultResult = hasPre ? 'prerelease' : '';\n\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key;\n        }\n      }\n    }\n\n    return defaultResult; // may be undefined\n  }\n};\n\nmodule.exports = diff;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/diff.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/eq.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/eq.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\");\n\nconst eq = (a, b, loose) => compare(a, b, loose) === 0;\n\nmodule.exports = eq;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/eq.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/gt.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/gt.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\");\n\nconst gt = (a, b, loose) => compare(a, b, loose) > 0;\n\nmodule.exports = gt;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/gt.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/gte.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/gte.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\");\n\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0;\n\nmodule.exports = gte;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/gte.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/inc.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/inc.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof options === 'string') {\n    identifier = options;\n    options = undefined;\n  }\n\n  try {\n    return new SemVer(version, options).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n};\n\nmodule.exports = inc;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/inc.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/lt.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/lt.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\");\n\nconst lt = (a, b, loose) => compare(a, b, loose) < 0;\n\nmodule.exports = lt;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/lt.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/lte.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/lte.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\");\n\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0;\n\nmodule.exports = lte;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/lte.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/major.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/major.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst major = (a, loose) => new SemVer(a, loose).major;\n\nmodule.exports = major;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/major.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/minor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/minor.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst minor = (a, loose) => new SemVer(a, loose).minor;\n\nmodule.exports = minor;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/minor.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/neq.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/neq.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\");\n\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0;\n\nmodule.exports = neq;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/neq.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/parse.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/parse.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const {\n  MAX_LENGTH\n} = __webpack_require__(/*! ../internal/constants */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/constants.js\");\n\nconst {\n  re,\n  t\n} = __webpack_require__(/*! ../internal/re */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/re.js\");\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/parse-options.js\");\n\nconst parse = (version, options) => {\n  options = parseOptions(options);\n\n  if (version instanceof SemVer) {\n    return version;\n  }\n\n  if (typeof version !== 'string') {\n    return null;\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null;\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL];\n\n  if (!r.test(version)) {\n    return null;\n  }\n\n  try {\n    return new SemVer(version, options);\n  } catch (er) {\n    return null;\n  }\n};\n\nmodule.exports = parse;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/parse.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/patch.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/patch.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst patch = (a, loose) => new SemVer(a, loose).patch;\n\nmodule.exports = patch;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/patch.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/prerelease.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/prerelease.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/parse.js\");\n\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options);\n  return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n};\n\nmodule.exports = prerelease;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/prerelease.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/rcompare.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/rcompare.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\");\n\nconst rcompare = (a, b, loose) => compare(b, a, loose);\n\nmodule.exports = rcompare;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/rcompare.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/rsort.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/rsort.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const compareBuild = __webpack_require__(/*! ./compare-build */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare-build.js\");\n\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));\n\nmodule.exports = rsort;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/rsort.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/satisfies.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/satisfies.js ***!
  \***********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\");\n\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options);\n  } catch (er) {\n    return false;\n  }\n\n  return range.test(version);\n};\n\nmodule.exports = satisfies;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/satisfies.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/sort.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/sort.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const compareBuild = __webpack_require__(/*! ./compare-build */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare-build.js\");\n\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));\n\nmodule.exports = sort;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/sort.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/functions/valid.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/functions/valid.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/parse.js\");\n\nconst valid = (version, options) => {\n  const v = parse(version, options);\n  return v ? v.version : null;\n};\n\nmodule.exports = valid;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/functions/valid.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/index.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// just pre-load all the stuff that index.js lazily exports\nconst internalRe = __webpack_require__(/*! ./internal/re */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/re.js\");\n\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: (__webpack_require__(/*! ./internal/constants */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/constants.js\").SEMVER_SPEC_VERSION),\n  SemVer: __webpack_require__(/*! ./classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\"),\n  compareIdentifiers: (__webpack_require__(/*! ./internal/identifiers */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/identifiers.js\").compareIdentifiers),\n  rcompareIdentifiers: (__webpack_require__(/*! ./internal/identifiers */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/identifiers.js\").rcompareIdentifiers),\n  parse: __webpack_require__(/*! ./functions/parse */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/parse.js\"),\n  valid: __webpack_require__(/*! ./functions/valid */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/valid.js\"),\n  clean: __webpack_require__(/*! ./functions/clean */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/clean.js\"),\n  inc: __webpack_require__(/*! ./functions/inc */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/inc.js\"),\n  diff: __webpack_require__(/*! ./functions/diff */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/diff.js\"),\n  major: __webpack_require__(/*! ./functions/major */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/major.js\"),\n  minor: __webpack_require__(/*! ./functions/minor */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/minor.js\"),\n  patch: __webpack_require__(/*! ./functions/patch */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/patch.js\"),\n  prerelease: __webpack_require__(/*! ./functions/prerelease */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/prerelease.js\"),\n  compare: __webpack_require__(/*! ./functions/compare */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\"),\n  rcompare: __webpack_require__(/*! ./functions/rcompare */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/rcompare.js\"),\n  compareLoose: __webpack_require__(/*! ./functions/compare-loose */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare-loose.js\"),\n  compareBuild: __webpack_require__(/*! ./functions/compare-build */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare-build.js\"),\n  sort: __webpack_require__(/*! ./functions/sort */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/sort.js\"),\n  rsort: __webpack_require__(/*! ./functions/rsort */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/rsort.js\"),\n  gt: __webpack_require__(/*! ./functions/gt */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/gt.js\"),\n  lt: __webpack_require__(/*! ./functions/lt */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/lt.js\"),\n  eq: __webpack_require__(/*! ./functions/eq */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/eq.js\"),\n  neq: __webpack_require__(/*! ./functions/neq */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/neq.js\"),\n  gte: __webpack_require__(/*! ./functions/gte */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/gte.js\"),\n  lte: __webpack_require__(/*! ./functions/lte */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/lte.js\"),\n  cmp: __webpack_require__(/*! ./functions/cmp */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/cmp.js\"),\n  coerce: __webpack_require__(/*! ./functions/coerce */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/coerce.js\"),\n  Comparator: __webpack_require__(/*! ./classes/comparator */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/comparator.js\"),\n  Range: __webpack_require__(/*! ./classes/range */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\"),\n  satisfies: __webpack_require__(/*! ./functions/satisfies */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/satisfies.js\"),\n  toComparators: __webpack_require__(/*! ./ranges/to-comparators */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/to-comparators.js\"),\n  maxSatisfying: __webpack_require__(/*! ./ranges/max-satisfying */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/max-satisfying.js\"),\n  minSatisfying: __webpack_require__(/*! ./ranges/min-satisfying */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/min-satisfying.js\"),\n  minVersion: __webpack_require__(/*! ./ranges/min-version */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/min-version.js\"),\n  validRange: __webpack_require__(/*! ./ranges/valid */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/valid.js\"),\n  outside: __webpack_require__(/*! ./ranges/outside */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/outside.js\"),\n  gtr: __webpack_require__(/*! ./ranges/gtr */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/gtr.js\"),\n  ltr: __webpack_require__(/*! ./ranges/ltr */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/ltr.js\"),\n  intersects: __webpack_require__(/*! ./ranges/intersects */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/intersects.js\"),\n  simplifyRange: __webpack_require__(/*! ./ranges/simplify */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/simplify.js\"),\n  subset: __webpack_require__(/*! ./ranges/subset */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/subset.js\")\n};\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/index.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/internal/constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/internal/constants.js ***!
  \**********************************************************************************/
/***/ (function(module) {

eval("// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0';\nconst MAX_LENGTH = 256;\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */\n9007199254740991; // Max safe segment length for coercion.\n\nconst MAX_SAFE_COMPONENT_LENGTH = 16;\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH\n};\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/internal/constants.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/internal/debug.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/internal/debug.js ***!
  \******************************************************************************/
/***/ (function(module) {

eval("const debug = typeof process === 'object' && ({\"VUE_APP_CLUSTER_URL\":\"https://api.devnet.solana.com\",\"NODE_ENV\":\"development\",\"BASE_URL\":\"/\"}) && ({\"VUE_APP_CLUSTER_URL\":\"https://api.devnet.solana.com\",\"NODE_ENV\":\"development\",\"BASE_URL\":\"/\"}).NODE_DEBUG && /\\bsemver\\b/i.test(({\"VUE_APP_CLUSTER_URL\":\"https://api.devnet.solana.com\",\"NODE_ENV\":\"development\",\"BASE_URL\":\"/\"}).NODE_DEBUG) ? (...args) => console.error('SEMVER', ...args) : () => {};\nmodule.exports = debug;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/internal/debug.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/internal/identifiers.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/internal/identifiers.js ***!
  \************************************************************************************/
/***/ (function(module) {

eval("const numeric = /^[0-9]+$/;\n\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a);\n  const bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n};\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers\n};\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/internal/identifiers.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/internal/parse-options.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/internal/parse-options.js ***!
  \**************************************************************************************/
/***/ (function(module) {

eval("// parse out just the options we care about so we always get a consistent\n// obj with keys in a consistent order.\nconst opts = ['includePrerelease', 'loose', 'rtl'];\n\nconst parseOptions = options => !options ? {} : typeof options !== 'object' ? {\n  loose: true\n} : opts.filter(k => options[k]).reduce((o, k) => {\n  o[k] = true;\n  return o;\n}, {});\n\nmodule.exports = parseOptions;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/internal/parse-options.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/internal/re.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/internal/re.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  MAX_SAFE_COMPONENT_LENGTH\n} = __webpack_require__(/*! ./constants */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/constants.js\");\n\nconst debug = __webpack_require__(/*! ./debug */ \"./node_modules/@ledgerhq/devices/node_modules/semver/internal/debug.js\");\n\nexports = module.exports = {}; // The actual regexps go on exports.re\n\nconst re = exports.re = [];\nconst src = exports.src = [];\nconst t = exports.t = {};\nlet R = 0;\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++;\n  debug(name, index, value);\n  t[name] = index;\n  src[index] = value;\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);\n}; // The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*');\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+'); // ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'); // ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` + `(${src[t.NUMERICIDENTIFIER]})\\\\.` + `(${src[t.NUMERICIDENTIFIER]})`);\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`); // ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`); // ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`); // ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+'); // ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`); // ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`); // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\n\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);\ncreateToken('GTLT', '((?:<|>)?=?)'); // Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\n\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`); // Coercion.\n// Extract anything that could conceivably be a part of a valid semver\n\ncreateToken('COERCE', `${'(^|[^\\\\d])' + '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:$|[^\\\\d])`);\ncreateToken('COERCERTL', src[t.COERCE], true); // Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\n\ncreateToken('LONETILDE', '(?:~>?)');\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\nexports.tildeTrimReplace = '$1~';\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`); // Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\n\ncreateToken('LONECARET', '(?:\\\\^)');\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\nexports.caretTrimReplace = '$1^';\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`); // A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\n\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`); // An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\n\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\nexports.comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\n\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` + `\\\\s+-\\\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\\\s*$`);\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\\\s+-\\\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\\\s*$`); // Star ranges basically just allow anything at all.\n\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*'); // >=0.0.0 is like a star\n\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$');\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$');\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/internal/re.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/gtr.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/gtr.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Determine if version is greater than all the versions possible in the range.\nconst outside = __webpack_require__(/*! ./outside */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/outside.js\");\n\nconst gtr = (version, range, options) => outside(version, range, '>', options);\n\nmodule.exports = gtr;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/gtr.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/intersects.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/intersects.js ***!
  \*********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\");\n\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options);\n  r2 = new Range(r2, options);\n  return r1.intersects(r2);\n};\n\nmodule.exports = intersects;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/intersects.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/ltr.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/ltr.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const outside = __webpack_require__(/*! ./outside */ \"./node_modules/@ledgerhq/devices/node_modules/semver/ranges/outside.js\"); // Determine if version is less than all the versions possible in the range\n\n\nconst ltr = (version, range, options) => outside(version, range, '<', options);\n\nmodule.exports = ltr;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/ltr.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/max-satisfying.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/max-satisfying.js ***!
  \*************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\");\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null;\n  let maxSV = null;\n  let rangeObj = null;\n\n  try {\n    rangeObj = new Range(range, options);\n  } catch (er) {\n    return null;\n  }\n\n  versions.forEach(v => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v;\n        maxSV = new SemVer(max, options);\n      }\n    }\n  });\n  return max;\n};\n\nmodule.exports = maxSatisfying;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/max-satisfying.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/min-satisfying.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/min-satisfying.js ***!
  \*************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\");\n\nconst minSatisfying = (versions, range, options) => {\n  let min = null;\n  let minSV = null;\n  let rangeObj = null;\n\n  try {\n    rangeObj = new Range(range, options);\n  } catch (er) {\n    return null;\n  }\n\n  versions.forEach(v => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v;\n        minSV = new SemVer(min, options);\n      }\n    }\n  });\n  return min;\n};\n\nmodule.exports = minSatisfying;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/min-satisfying.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/min-version.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/min-version.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\");\n\nconst gt = __webpack_require__(/*! ../functions/gt */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/gt.js\");\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose);\n  let minver = new SemVer('0.0.0');\n\n  if (range.test(minver)) {\n    return minver;\n  }\n\n  minver = new SemVer('0.0.0-0');\n\n  if (range.test(minver)) {\n    return minver;\n  }\n\n  minver = null;\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i];\n    let setMin = null;\n    comparators.forEach(comparator => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version);\n\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++;\n          } else {\n            compver.prerelease.push(0);\n          }\n\n          compver.raw = compver.format();\n\n        /* fallthrough */\n\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver;\n          }\n\n          break;\n\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`);\n      }\n    });\n\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin;\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver;\n  }\n\n  return null;\n};\n\nmodule.exports = minVersion;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/min-version.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/outside.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/outside.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/semver.js\");\n\nconst Comparator = __webpack_require__(/*! ../classes/comparator */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/comparator.js\");\n\nconst {\n  ANY\n} = Comparator;\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\");\n\nconst satisfies = __webpack_require__(/*! ../functions/satisfies */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/satisfies.js\");\n\nconst gt = __webpack_require__(/*! ../functions/gt */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/gt.js\");\n\nconst lt = __webpack_require__(/*! ../functions/lt */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/lt.js\");\n\nconst lte = __webpack_require__(/*! ../functions/lte */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/lte.js\");\n\nconst gte = __webpack_require__(/*! ../functions/gte */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/gte.js\");\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options);\n  range = new Range(range, options);\n  let gtfn, ltefn, ltfn, comp, ecomp;\n\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  } // If it satisfies the range it is not outside\n\n\n  if (satisfies(version, range, options)) {\n    return false;\n  } // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i];\n    let high = null;\n    let low = null;\n    comparators.forEach(comparator => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0');\n      }\n\n      high = high || comparator;\n      low = low || comparator;\n\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator;\n      }\n    }); // If the edge version comparator has a operator then our version\n    // isn't outside it\n\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    } // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n\n\n    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = outside;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/outside.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/simplify.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/simplify.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/satisfies.js\");\n\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\");\n\nmodule.exports = (versions, range, options) => {\n  const set = [];\n  let first = null;\n  let prev = null;\n  const v = versions.sort((a, b) => compare(a, b, options));\n\n  for (const version of v) {\n    const included = satisfies(version, range, options);\n\n    if (included) {\n      prev = version;\n\n      if (!first) {\n        first = version;\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev]);\n      }\n\n      prev = null;\n      first = null;\n    }\n  }\n\n  if (first) {\n    set.push([first, null]);\n  }\n\n  const ranges = [];\n\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min);\n    } else if (!max && min === v[0]) {\n      ranges.push('*');\n    } else if (!max) {\n      ranges.push(`>=${min}`);\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`);\n    } else {\n      ranges.push(`${min} - ${max}`);\n    }\n  }\n\n  const simplified = ranges.join(' || ');\n  const original = typeof range.raw === 'string' ? range.raw : String(range);\n  return simplified.length < original.length ? simplified : range;\n};\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/simplify.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/subset.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/subset.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Range = __webpack_require__(/*! ../classes/range.js */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\");\n\nconst Comparator = __webpack_require__(/*! ../classes/comparator.js */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/comparator.js\");\n\nconst {\n  ANY\n} = Comparator;\n\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/satisfies.js\");\n\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"./node_modules/@ledgerhq/devices/node_modules/semver/functions/compare.js\"); // Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true;\n  }\n\n  sub = new Range(sub, options);\n  dom = new Range(dom, options);\n  let sawNonNull = false;\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options);\n      sawNonNull = sawNonNull || isSub !== null;\n\n      if (isSub) {\n        continue OUTER;\n      }\n    } // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n\n\n    if (sawNonNull) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true;\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true;\n    } else if (options.includePrerelease) {\n      sub = [new Comparator('>=0.0.0-0')];\n    } else {\n      sub = [new Comparator('>=0.0.0')];\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true;\n    } else {\n      dom = [new Comparator('>=0.0.0')];\n    }\n  }\n\n  const eqSet = new Set();\n  let gt, lt;\n\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options);\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options);\n    } else {\n      eqSet.add(c.semver);\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null;\n  }\n\n  let gtltComp;\n\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options);\n\n    if (gtltComp > 0) {\n      return null;\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null;\n    }\n  } // will iterate one or zero times\n\n\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null;\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null;\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  let higher, lower;\n  let hasDomLT, hasDomGT; // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n\n  let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;\n  let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false; // exception: <1.2.3-0 is the same as <1.2.3\n\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false;\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';\n\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false;\n        }\n      }\n\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options);\n\n        if (higher === c && higher !== gt) {\n          return false;\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false;\n      }\n    }\n\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false;\n        }\n      }\n\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options);\n\n        if (lower === c && lower !== lt) {\n          return false;\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false;\n      }\n    }\n\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false;\n    }\n  } // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n\n\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false;\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false;\n  } // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n\n\n  if (needDomGTPre || needDomLTPre) {\n    return false;\n  }\n\n  return true;\n}; // >=1.2.3 is lower than >1.2.3\n\n\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b;\n  }\n\n  const comp = compare(a.semver, b.semver, options);\n  return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;\n}; // <=1.2.3 is higher than <1.2.3\n\n\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b;\n  }\n\n  const comp = compare(a.semver, b.semver, options);\n  return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;\n};\n\nmodule.exports = subset;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/subset.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/to-comparators.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/to-comparators.js ***!
  \*************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\"); // Mostly just for testing and legacy API reasons\n\n\nconst toComparators = (range, options) => new Range(range, options).set.map(comp => comp.map(c => c.value).join(' ').trim().split(' '));\n\nmodule.exports = toComparators;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/to-comparators.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/node_modules/semver/ranges/valid.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/node_modules/semver/ranges/valid.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/@ledgerhq/devices/node_modules/semver/classes/range.js\");\n\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*';\n  } catch (er) {\n    return null;\n  }\n};\n\nmodule.exports = validRange;\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/devices/node_modules/semver/ranges/valid.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport-webhid/lib-es/TransportWebHID.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport-webhid/lib-es/TransportWebHID.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ledgerhq_hw_transport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ledgerhq/hw-transport */ \"./node_modules/@ledgerhq/hw-transport/lib-es/Transport.js\");\n/* harmony import */ var _ledgerhq_devices_lib_hid_framing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ledgerhq/devices/lib/hid-framing */ \"./node_modules/@ledgerhq/devices/lib/hid-framing.js\");\n/* harmony import */ var _ledgerhq_devices__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ledgerhq/devices */ \"./node_modules/@ledgerhq/devices/lib-es/index.js\");\n/* harmony import */ var _ledgerhq_logs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ledgerhq/logs */ \"./node_modules/@ledgerhq/logs/lib-es/index.js\");\n/* harmony import */ var _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ledgerhq/errors */ \"./node_modules/@ledgerhq/errors/lib-es/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = undefined && undefined.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\n\n\n\n\n\nvar ledgerDevices = [{\n  vendorId: _ledgerhq_devices__WEBPACK_IMPORTED_MODULE_3__.ledgerUSBVendorId\n}];\n\nvar isSupported = function () {\n  return Promise.resolve(!!(window.navigator && window.navigator.hid));\n};\n\nvar getHID = function () {\n  // $FlowFixMe\n  var hid = navigator.hid;\n  if (!hid) throw new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_5__.TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\n\nfunction requestLedgerDevices() {\n  return __awaiter(this, void 0, void 0, function () {\n    var device;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , getHID().requestDevice({\n            filters: ledgerDevices\n          })];\n\n        case 1:\n          device = _a.sent();\n          if (Array.isArray(device)) return [2\n          /*return*/\n          , device];\n          return [2\n          /*return*/\n          , [device]];\n      }\n    });\n  });\n}\n\nfunction getLedgerDevices() {\n  return __awaiter(this, void 0, void 0, function () {\n    var devices;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , getHID().getDevices()];\n\n        case 1:\n          devices = _a.sent();\n          return [2\n          /*return*/\n          , devices.filter(function (d) {\n            return d.vendorId === _ledgerhq_devices__WEBPACK_IMPORTED_MODULE_3__.ledgerUSBVendorId;\n          })];\n      }\n    });\n  });\n}\n\nfunction getFirstLedgerDevice() {\n  return __awaiter(this, void 0, void 0, function () {\n    var existingDevices, devices;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , getLedgerDevices()];\n\n        case 1:\n          existingDevices = _a.sent();\n          if (existingDevices.length > 0) return [2\n          /*return*/\n          , existingDevices[0]];\n          return [4\n          /*yield*/\n          , requestLedgerDevices()];\n\n        case 2:\n          devices = _a.sent();\n          return [2\n          /*return*/\n          , devices[0]];\n      }\n    });\n  });\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\n\nvar TransportWebHID =\n/** @class */\nfunction (_super) {\n  __extends(TransportWebHID, _super);\n\n  function TransportWebHID(device) {\n    var _this = _super.call(this) || this;\n\n    _this.channel = Math.floor(Math.random() * 0xffff);\n    _this.packetSize = 64;\n    _this.inputs = [];\n\n    _this.read = function () {\n      if (_this.inputs.length) {\n        return Promise.resolve(_this.inputs.shift());\n      }\n\n      return new Promise(function (success) {\n        _this.inputCallback = success;\n      });\n    };\n\n    _this.onInputReport = function (e) {\n      var buffer = Buffer.from(e.data.buffer);\n\n      if (_this.inputCallback) {\n        _this.inputCallback(buffer);\n\n        _this.inputCallback = null;\n      } else {\n        _this.inputs.push(buffer);\n      }\n    };\n\n    _this._disconnectEmitted = false;\n\n    _this._emitDisconnect = function (e) {\n      if (_this._disconnectEmitted) return;\n      _this._disconnectEmitted = true;\n\n      _this.emit(\"disconnect\", e);\n    };\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n\n\n    _this.exchange = function (apdu) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var b;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.exchangeAtomicImpl(function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var _a, channel, packetSize, framing, blocks, i, result, acc, buffer;\n\n                  return __generator(this, function (_b) {\n                    switch (_b.label) {\n                      case 0:\n                        _a = this, channel = _a.channel, packetSize = _a.packetSize;\n                        (0,_ledgerhq_logs__WEBPACK_IMPORTED_MODULE_4__.log)(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n                        framing = (0,_ledgerhq_devices_lib_hid_framing__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(channel, packetSize);\n                        blocks = framing.makeBlocks(apdu);\n                        i = 0;\n                        _b.label = 1;\n\n                      case 1:\n                        if (!(i < blocks.length)) return [3\n                        /*break*/\n                        , 4];\n                        return [4\n                        /*yield*/\n                        , this.device.sendReport(0, blocks[i])];\n\n                      case 2:\n                        _b.sent();\n\n                        _b.label = 3;\n\n                      case 3:\n                        i++;\n                        return [3\n                        /*break*/\n                        , 1];\n\n                      case 4:\n                        if (!!(result = framing.getReducedResult(acc))) return [3\n                        /*break*/\n                        , 6];\n                        return [4\n                        /*yield*/\n                        , this.read()];\n\n                      case 5:\n                        buffer = _b.sent();\n                        acc = framing.reduceResponse(acc, buffer);\n                        return [3\n                        /*break*/\n                        , 4];\n\n                      case 6:\n                        (0,_ledgerhq_logs__WEBPACK_IMPORTED_MODULE_4__.log)(\"apdu\", \"<= \" + result.toString(\"hex\"));\n                        return [2\n                        /*return*/\n                        , result];\n                    }\n                  });\n                });\n              })[\"catch\"](function (e) {\n                if (e && e.message && e.message.includes(\"write\")) {\n                  _this._emitDisconnect(e);\n\n                  throw new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_5__.DisconnectedDeviceDuringOperation(e.message);\n                }\n\n                throw e;\n              })];\n\n            case 1:\n              b = _a.sent();\n              return [2\n              /*return*/\n              , b];\n          }\n        });\n      });\n    };\n\n    _this.device = device;\n    _this.deviceModel = typeof device.productId === \"number\" ? (0,_ledgerhq_devices__WEBPACK_IMPORTED_MODULE_3__.identifyUSBProductId)(device.productId) : undefined;\n    device.addEventListener(\"inputreport\", _this.onInputReport);\n    return _this;\n  }\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  TransportWebHID.request = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, device;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , requestLedgerDevices()];\n\n          case 1:\n            _a = __read.apply(void 0, [_b.sent(), 1]), device = _a[0];\n            return [2\n            /*return*/\n            , TransportWebHID.open(device)];\n        }\n      });\n    });\n  };\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n\n  TransportWebHID.openConnected = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var devices;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , getLedgerDevices()];\n\n          case 1:\n            devices = _a.sent();\n            if (devices.length === 0) return [2\n            /*return*/\n            , null];\n            return [2\n            /*return*/\n            , TransportWebHID.open(devices[0])];\n        }\n      });\n    });\n  };\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n\n\n  TransportWebHID.open = function (device) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transport, onDisconnect;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , device.open()];\n\n          case 1:\n            _a.sent();\n\n            transport = new TransportWebHID(device);\n\n            onDisconnect = function (e) {\n              if (device === e.device) {\n                getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n                transport._emitDisconnect(new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_5__.DisconnectedDevice());\n              }\n            };\n\n            getHID().addEventListener(\"disconnect\", onDisconnect);\n            return [2\n            /*return*/\n            , transport];\n        }\n      });\n    });\n  };\n  /**\n   * Release the transport device\n   */\n\n\n  TransportWebHID.prototype.close = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.exchangeBusyPromise];\n\n          case 1:\n            _a.sent();\n\n            this.device.removeEventListener(\"inputreport\", this.onInputReport);\n            return [4\n            /*yield*/\n            , this.device.close()];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  TransportWebHID.prototype.setScrambleKey = function () {};\n  /**\n   * Check if WebUSB transport is supported.\n   */\n\n\n  TransportWebHID.isSupported = isSupported;\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n\n  TransportWebHID.list = getLedgerDevices;\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n\n  TransportWebHID.listen = function (observer) {\n    var unsubscribed = false;\n    getFirstLedgerDevice().then(function (device) {\n      if (!device) {\n        observer.error(new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_5__.TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n      } else if (!unsubscribed) {\n        var deviceModel = typeof device.productId === \"number\" ? (0,_ledgerhq_devices__WEBPACK_IMPORTED_MODULE_3__.identifyUSBProductId)(device.productId) : undefined;\n        observer.next({\n          type: \"add\",\n          descriptor: device,\n          deviceModel: deviceModel\n        });\n        observer.complete();\n      }\n    }, function (error) {\n      observer.error(new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_5__.TransportOpenUserCancelled(error.message));\n    });\n\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n\n    return {\n      unsubscribe: unsubscribe\n    };\n  };\n\n  return TransportWebHID;\n}(_ledgerhq_hw_transport__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (TransportWebHID);\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/hw-transport-webhid/lib-es/TransportWebHID.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/logs/lib-es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@ledgerhq/logs/lib-es/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"listen\": function() { return /* binding */ listen; },\n/* harmony export */   \"log\": function() { return /* binding */ log; }\n/* harmony export */ });\nvar id = 0;\nvar subscribers = [];\n/**\n * log something\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\n\nvar log = function (type, message, data) {\n  var obj = {\n    type: type,\n    id: String(++id),\n    date: new Date()\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n/**\n * listen to logs.\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\n\nvar listen = function (cb) {\n  subscribers.push(cb);\n  return function () {\n    var i = subscribers.indexOf(cb);\n\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log) {\n  for (var i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n\n//# sourceURL=webpack://app/./node_modules/@ledgerhq/logs/lib-es/index.js?");

/***/ })

}]);